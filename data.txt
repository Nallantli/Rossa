EntryNode := ExprNode*

MapElement :=
|	(ID|String) ':' EquNode

BaseNode :=
|	Number
|	String
|	Boolean
|	ID
|	'[' ']'
|	'{' MapElement* '}'
|	BaseNode '.' BaseNode
|	'var' ID

SigNode :=
|	'(' ('final'|'ref') String [',' ('final'|'ref') String]* ')'

UnitNode :=
|	UOP EquNode
|	'(' EquNode ')'
|	'[' EquNode [',' EquNode]* ']'
|	'@' SigNode '{' ExprNode* '}'
|	'extern_call' String '.' String '(' [EquNode [',' EquNode]*] ')'
|	'new' BaseNode '(' [EquNode [',' EquNode]*] ')'
|	BaseNode
|	UnitNode '(' [EquNode [',' EquNode]*] ')'
|	UnitNode '[' EquNode ']'
|	EquNode '(' [EquNode [',' EquNode]*] ')'
|	EquNode '[' EquNode ']'

EquNode :=
|	UnitNode
|	UnitNode BOP UnitNode [BOP UnitNode]*

CaseStatement :=
|	BaseNode 'do' '{' ExprNode* '}'

ExprNode :=
|	'load' String ';'
|	'extern' Type ID '(' Type* ')' 'in' String ';'
|	String SigNode => '{' ExprNode* '}'
|	Type :: String SigNode => '{' ExprNode* '}'
|	'for' ID 'in' EquNode 'do' '{' ExprNode* '}'
|	'while' EquNode 'do' '{' ExprNode* '}'
|	ClassType String 'class' '{' ExprNode* '}'
|	'if' EquNode 'then' '{' ExprNode* '}' ['elseif' EquNode 'then' '{' ExprNode* '}']* ['else' '{' ExprNode* '}']
|	'return' EquNode ';'
|	EquNode ';'
|	'switch' EquNode 'in' '{' CaseStatement '}' 'else' { ExprNode* }

ID := [a-zA-Z][a-zA-Z0-9]*